# TinyFrame

TinyFrame 是一个用于构建和解析通过串行接口（如 UART、telnet、socket）发送的数据帧的简单库。代码编写为使用 `--std=gnu99` 构建，并且大部分兼容 `--std=gnu89`。

该库提供了一个高级接口，用于在对等方之间传递消息。多消息会话、响应监听器、校验和、超时都由库处理。

TinyFrame 适用于广泛的应用，包括微控制器之间的通信、基于 FTDI 的 PC 应用程序协议或通过 UDP 数据包的消息传递。

该库允许您注册监听器（回调函数）以等待（1）任何帧、（2）特定的帧类型或（3）特定的消息 ID。这个高级 API 通用性足以实现大多数通信模式。

TinyFrame 是可重入的，支持创建多个实例，限制是它们的结构（字段大小和校验和类型）必须相同。支持使用互斥锁添加对共享实例的多线程访问。

TinyFrame 还附带（可选的）辅助函数，用于构建和解析消息负载，这些函数在 `utils/` 文件夹中提供。

## 移植

TinyFrame 已被移植到多种语言：

- 参考的 C 实现在此存储库中
- Python 移植版本 - [MightyPork/PonyFrame](https://github.com/MightyPork/PonyFrame)
- Rust 移植版本 - [cpsdqs/tinyframe-rs](https://github.com/cpsdqs/tinyframe-rs)
- JavaScript 移植版本 - [cpsdqs/tinyframe-js](https://github.com/cpsdqs/tinyframe-js)

请注意，大多数移植版本都是实验性的，可能会出现各种错误或缺少功能。欢迎测试者：）

## 功能概述

这里解释了 TinyFrame 的基本功能。对于详细信息，如 API 函数，建议阅读头文件中的文档注释。

### 帧结构

每个帧由头部和负载组成。两个部分都可以受到校验和保护，确保格式错误的头部（例如，损坏的长度字段）或损坏的负载的帧被拒绝。

帧头包含帧 ID 和消息类型。帧 ID 随每条新消息递增。ID 字段的最高位对于两个对等方固定为 1 和 0，以避免冲突。

可以在响应中重用帧 ID，将两条消息联系在一起。类型字段的值由用户定义。

帧中的所有字段都有可配置的大小。通过更改配置文件中的字段，如 `TF_LEN_BYTES`（1、2 或 4），库在使用该字段的所有函数之间无缝切换 `uint8_t`、`uint16_t` 和 `uint32_t`。

```
,-----+-----+-----+------+------------+- - - -+-------------,
| SOF | ID  | LEN | TYPE | HEAD_CKSUM | DATA  | DATA_CKSUM  |
| 0-1 | 1-4 | 1-4 | 1-4  | 0-4        | ...   | 0-4         | <- size (bytes)
'-----+-----+-----+------+------------+- - - -+-------------'

SOF ......... 帧开始，通常是 0x01（可选，可配置）
ID  ......... 帧 ID（最高位是对等方位）
LEN ......... 帧中的数据字节数
TYPE ........ 消息类型（用于运行类型监听器，选择任何您喜欢的值）
HEAD_CKSUM .. 头部校验和

DATA ........ LEN 字节的数据
DATA_CKSUM .. 数据校验和（如果 LEN 为 0，则省略）
```

### 消息监听器

TinyFrame 基于消息监听器的概念。监听器是等待接收特定消息类型或 ID 的回调函数。

有 3 种监听器类型，按优先级排序：
 
- **ID 监听器** - 等待响应
- **类型监听器** - 等待给定类型字段的消息
- **通用监听器** - 回退

发送消息时可以自动注册 ID 监听器。所有监听器也可以手动注册和删除。

ID 监听器用于接收对请求的响应。注册 ID 监听器时，可以附加自定义用户数据，该数据将可供监听器回调使用。此数据（`void *`）可以是任何类型的应用程序上下文变量。

可以为 ID 监听器分配超时。当监听器过期时，在它被移除之前，回调将使用 NULL 负载数据触发，以便让用户 `free()` 任何附加的 userdata。仅当 userdata 不为 NULL 时才会发生这种情况。

监听器回调返回 `TF_Result` 枚举的值：

- `TF_CLOSE` - 消息已接受，移除监听器
- `TF_STAY` - 消息已接受，保持注册状态
- `TF_RENEW` - 与 `TF_STAY` 相同，但 ID 监听器的超时被续期
- `TF_NEXT` - 消息未接受，保持监听器并将消息传递给下一个能够处理它的监听器。

### 数据缓冲区、多部分帧

TinyFrame 使用两个数据缓冲区：一个小的发送缓冲区和一个较大的接收缓冲区。
发送缓冲区用于准备要发送的字节，可以一次性发送，如果缓冲区不够大，则可以循环方式发送。缓冲区只需要包含完整的帧头，因此例如 32 字节应该足以用于短消息。

使用 `*_Multipart()` 发送函数，还可以将帧头和负载拆分为多个函数调用，允许应用程序例如即时生成负载。

与发送缓冲区相反，接收缓冲区必须足够大以包含整个帧。这是因为在处理帧之前必须验证最终校验和。
 
如果需要大于可能接收缓冲区大小的帧（例如在 RAM 较小的嵌入式系统中），建议在更高级别实现多消息传输机制，并分块发送数据。

## 使用提示

- 所有 TinyFrame 函数、typedef 和宏都以 `TF_` 前缀开头。
- 两个对等方必须使用相同的配置参数包含库
- 参考 `TF_Integration.example.c` 和 `TF_Config.example.c` 了解如何配置和集成库。
- 如果可能，不要修改库文件。这使得升级变得容易。
- 通过调用 `TF_Init()` 并使用 `TF_MASTER` 或 `TF_SLAVE` 作为参数开始。这将创建一个句柄。
  使用 `TF_InitStatic()` 避免使用 malloc()。 
- 如果使用多个实例，可以使用 `tf.userdata` / `tf.usertag` 字段标记它们。
- 实现 `TF_WriteImpl()` - 在头文件底部声明为 `extern`。
  此函数由 `TF_Send()` 和其他函数用于将字节写入您的 UART（或其他物理层）。
  帧可以整体发送，也可以分多次发送，具体取决于其大小。
- 使用 TF_AcceptChar(tf, byte) 将读取数据提供给 TF。TF_Accept(tf, bytes, count) 将接受多个字节。  
- 如果希望使用超时，请定期调用 `TF_Tick()`。调用周期确定 1 个 tick 的长度。这用于在解析器陷入错误状态（例如接收部分帧）时使解析器超时，也可以使 ID 监听器超时。
- 使用 `TF_AddTypeListener()` 或 `TF_AddGenericListener()` 绑定类型或通用监听器。
- 使用 `TF_Send()`、`TF_Query()`、`TF_SendSimple()`、`TF_QuerySimple()` 发送消息。
  查询函数采用监听器回调（函数指针），该指针将被添加为 ID 监听器并等待响应。
- 使用上述发送函数的 `*_Multipart()` 变体以在多个函数调用中生成的负载。
  然后通过调用 `TF_Multipart_Payload()` 发送负载，并通过 `TF_Multipart_Close()` 关闭帧。
- 如果需要自定义校验和实现，请选择 `TF_CKSUM_CUSTOM8`、16 或 32 并实现三个校验和函数。
- 要回复消息（当您的监听器被调用时），使用 `TF_Respond()`
  和您收到的 msg 对象，用响应替换 `data` 指针（以及 `len`）。
- 您可以随时使用 `TF_ResetParser()` 手动重置消息解析器。它还可以在配置文件中配置的超时后自动重置。

### 需要注意的事项

- 如果将任何 userdata 附加到具有超时的 ID 监听器，当监听器超时时，
  它将使用 NULL `msg->data` 被调用，以便让用户释放 userdata。因此
  需要在继续处理消息之前检查 `msg->data`。
- 如果正在发送多部分帧，则库的 Tx 部分被锁定以防止并发访问。
  必须完全发送并关闭帧，然后才能尝试发送其他任何内容。 
- 如果使用多个线程，请别忘了实现互斥锁回调以避免并发访问 Tx 函数。默认实现不是完全线程安全的，因为它不能依赖平台特定的资源，如互斥锁或原子访问。
  在配置文件中将 `TF_USE_MUTEX` 设置为 `1`。

### 示例

您将在 `demo/` 文件夹中找到各种示例。每个示例都有自己的 Makefile，
阅读它以查看有哪些选项。

演示是为 Linux 编写的，一些使用套接字和 `clone()` 进行后台处理。
它们尝试模拟嵌入式系统中具有异步 Rx 和 Tx 的真实 TinyFrame 行为。如果您无法运行演示，源文件仍然是很好的示例。
